<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fitting Ensembles of ODE Models to Data · DiffEqParamEstim.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/DiffEqParamEstim/stable/tutorials/ensemble/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DiffEqParamEstim.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DiffEqParamEstim.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">DiffEqParamEstim.jl: Parameter Estimation for Differential Equations</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../ODE_inference/">Optimization-Based ODE Parameter Estimation</a></li><li><a class="tocitem" href="../global_optimization/">Global Optimization via NLopt</a></li><li><a class="tocitem" href="../jump/">Using JuMP with DiffEqParamEstim</a></li><li><a class="tocitem" href="../generalized_likelihood/">Generalized Likelihood Inference</a></li><li><a class="tocitem" href="../stochastic_evaluations/">Parameter Estimation for Stochastic Differential Equations and Ensembles</a></li><li class="is-active"><a class="tocitem" href>Fitting Ensembles of ODE Models to Data</a><ul class="internal"><li><a class="tocitem" href="#Formulating-the-Ensemble-Model"><span>Formulating the Ensemble Model</span></a></li></ul></li></ul></li><li><span class="tocitem">Methods</span><ul><li><a class="tocitem" href="../../methods/recommended_methods/">Recommended Methods</a></li><li><a class="tocitem" href="../../methods/optimization_based_methods/">Optimization-Based Methods</a></li><li><a class="tocitem" href="../../methods/collocation_loss/">Two Stage method (Non-Parametric Collocation)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Fitting Ensembles of ODE Models to Data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Fitting Ensembles of ODE Models to Data</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/DiffEqParamEstim.jl/blob/master/docs/src/tutorials/ensemble.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Fitting-Ensembles-of-ODE-Models-to-Data"><a class="docs-heading-anchor" href="#Fitting-Ensembles-of-ODE-Models-to-Data">Fitting Ensembles of ODE Models to Data</a><a id="Fitting-Ensembles-of-ODE-Models-to-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-Ensembles-of-ODE-Models-to-Data" title="Permalink"></a></h1><p>In this tutoiral we will showcase how to fit multiple models simultaniously to respective data sources. Let&#39;s dive right in!</p><h2 id="Formulating-the-Ensemble-Model"><a class="docs-heading-anchor" href="#Formulating-the-Ensemble-Model">Formulating the Ensemble Model</a><a id="Formulating-the-Ensemble-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Formulating-the-Ensemble-Model" title="Permalink"></a></h2><p>First you want to create a problem which solves multiple problems at the same time. This is the <code>EnsembleProblem</code>. When the parameter estimation tools say it will take any DEProblem, it really means ANY DEProblem, which includes <code>EnsembleProblem</code>.</p><p>So, let&#39;s get an <code>EnsembleProblem</code> setup that solves with 10 different initial conditions. This looks as follows:</p><pre><code class="language- hljs">using DifferentialEquations, DiffEqParamEstim, Plots, Optimization, ForwardDiff, OptimizationOptimJL

# Monte Carlo Problem Set Up for solving set of ODEs with different initial conditions

# Set up Lotka-Volterra system
function pf_func(du,u,p,t)
  du[1] = p[1] * u[1] - p[2] * u[1]*u[2]
  du[2] = -3 * u[2] + u[1]*u[2]
end
p = [1.5,1.0]
prob = ODEProblem(pf_func,[1.0,1.0],(0.0,10.0),p)</code></pre><p>Now for an EnsembleProblem we have to take this problem and tell it what to do N times via the <code>prob_func</code>. So let&#39;s generate N=10 different initial conditions, and tell it to run the same problem but with these 10 different initial conditions each time:</p><pre><code class="language- hljs"># Setting up to solve the problem N times (for the N different initial conditions)
N = 10;
initial_conditions = [[1.0,1.0], [1.0,1.5], [1.5,1.0], [1.5,1.5], [0.5,1.0], [1.0,0.5], [0.5,0.5], [2.0,1.0], [1.0,2.0], [2.0,2.0]]
function prob_func(prob,i,repeat)
  ODEProblem(prob.f,initial_conditions[i],prob.tspan,prob.p)
end
enprob = EnsembleProblem(prob,prob_func=prob_func)</code></pre><p>We can check this does what we want by solving it:</p><pre><code class="language- hljs"># Check above does what we want
sim = solve(enprob,Tsit5(),trajectories=N)
plot(sim)</code></pre><p><code>trajectories=N</code> means &quot;run N times&quot;, and each time it runs the problem returned by the <code>prob_func</code>, which is always the same problem but with the <code>i</code>th initial condition.</p><p>Now let&#39;s generate a dataset from that. Let&#39;s get data points at every t=0.1 using <code>saveat</code>, and then convert the solution into an array.</p><pre><code class="language- hljs"># Generate a dataset from these runs
data_times = 0.0:0.1:10.0
sim = solve(enprob,Tsit5(),trajectories=N,saveat=data_times)
data = Array(sim)</code></pre><p>Here, <code>data[i,j,k]</code> is the same as <code>sim[i,j,k]</code> which is the same as <code>sim[k][i,j]</code> (where <code>sim[k]</code> is the <code>k</code>th solution). So <code>data[i,j,k]</code> is the <code>j</code>th timepoint of the <code>i</code>th variable in the <code>k</code>th trajectory.</p><p>Now let&#39;s build a loss function. A loss function is some <code>loss(sol)</code> that spits out a scalar for how far from optimal we are. In the documentation I show that we normally do <code>loss = L2Loss(t,data)</code>, but we can bootstrap off of this. Instead lets build an array of <code>N</code> loss functions, each one with the correct piece of data.</p><pre><code class="language- hljs"># Building a loss function
losses = [L2Loss(data_times,data[:,:,i]) for i in 1:N]</code></pre><p>So <code>losses[i]</code> is a function which computes the loss of a solution against the data of the ith trajectory. So to build our true loss function, we sum the losses:</p><pre><code class="language-julia hljs">loss(sim) = sum(losses[i](sim[i]) for i in 1:N)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">loss (generic function with 1 method)</code></pre><p>As a double check, make sure that <code>loss(sim)</code> outputs zero (since we generated the data from sim). Now we generate data with other parameters:</p><pre><code class="language- hljs">prob = ODEProblem(pf_func,[1.0,1.0],(0.0,10.0),[1.2,0.8])
function prob_func(prob,i,repeat)
  ODEProblem(prob.f,initial_conditions[i],prob.tspan,prob.p)
end
enprob = EnsembleProblem(prob,prob_func=prob_func)
sim = solve(enprob,Tsit5(),trajectories=N,saveat=data_times)
loss(sim)</code></pre><p>and get a non-zero loss. So we now have our problem, our data, and our loss function... we have what we need.</p><p>Put this into build<em>loss</em>objective.</p><pre><code class="language- hljs">obj = build_loss_objective(enprob,Tsit5(),loss,Optimization.AutoForwardDiff(),trajectories=N,
                           saveat=data_times)</code></pre><p>Notice that we added the kwargs for <code>solve</code> of the <code>EnsembleProblem</code> into this. They get passed to the internal <code>solve</code> command, so then the loss is computed on <code>N</code> trajectories at <code>data_times</code>.</p><p>Thus we take this objective function over to any optimization package. Here, since the Lotka-Volterra equation requires positive parameters, we use Fminbox to make sure the parameters stay within passed bounds. Let&#39;s start the optimization with [1.3,0.9], Optim spits out that the true parameters are:</p><pre><code class="language- hljs">lower = zeros(2)
upper = fill(2.0,2)
optprob = OptimizationProblem(obj,[1.3,0.9],lb = lower,ub = upper)
result = solve(optprob, Fminbox(BFGS()))</code></pre><pre><code class="language- hljs">result</code></pre><p>Optim finds one but not the other parameter.</p><p>It is advised to run a test on synthetic data for your problem before using it on real data. Maybe play around with different optimization packages, or add regularization. You may also want to decrease the tolerance of the ODE solvers via</p><pre><code class="language- hljs">obj = build_loss_objective(enprob,Tsit5(),loss, Optimization.AutoForwardDiff(), trajectories=N,
                           abstol=1e-8,reltol=1e-8,
                           saveat=data_times)
optprob = OptimizationProblem(obj, [1.3,0.9], lb = lower, ub = upper)
result = solve(optprob, BFGS()) #OptimizationOptimJL detects that it&#39;s a box constrained problem and use Fminbox wrapper over BFGS</code></pre><pre><code class="language- hljs">result</code></pre><p>if you suspect error is the problem. However, if you&#39;re having problems it&#39;s most likely not the ODE solver tolerance and mostly because parameter inference is a very hard optimization problem.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../stochastic_evaluations/">« Parameter Estimation for Stochastic Differential Equations and Ensembles</a><a class="docs-footer-nextpage" href="../../methods/recommended_methods/">Recommended Methods »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 21 December 2022 09:36">Wednesday 21 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
